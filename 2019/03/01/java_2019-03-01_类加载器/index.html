<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="类加载,ClassLoader,">










<meta name="description" content="阅读本文你能收获到  了解 Java/Android中类加载器及其工作流程 Android 开发过程中类加载器的应用场景  类加载器类加载器是虚拟机运行时动态加载字节码文件的入口。注意这里的虚拟机并不特指 Java虚拟机 或 Android虚拟机。通常来说开发者写的代码经过“前端编译器”编译成字节码文件集（Java-jar, Android-dex等）之后交给虚拟机，而虚拟机加载这些字节码文件集就">
<meta name="keywords" content="类加载,ClassLoader">
<meta property="og:type" content="article">
<meta property="og:title" content="聊一聊 &quot;类加载器&quot;">
<meta property="og:url" content="http://yummylau.com/2019/03/01/java_2019-03-01_类加载器/index.html">
<meta property="og:site_name" content="YummyLau">
<meta property="og:description" content="阅读本文你能收获到  了解 Java/Android中类加载器及其工作流程 Android 开发过程中类加载器的应用场景  类加载器类加载器是虚拟机运行时动态加载字节码文件的入口。注意这里的虚拟机并不特指 Java虚拟机 或 Android虚拟机。通常来说开发者写的代码经过“前端编译器”编译成字节码文件集（Java-jar, Android-dex等）之后交给虚拟机，而虚拟机加载这些字节码文件集就">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_3.png">
<meta property="og:updated_time" content="2019-03-10T05:35:03.475Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="聊一聊 &quot;类加载器&quot;">
<meta name="twitter:description" content="阅读本文你能收获到  了解 Java/Android中类加载器及其工作流程 Android 开发过程中类加载器的应用场景  类加载器类加载器是虚拟机运行时动态加载字节码文件的入口。注意这里的虚拟机并不特指 Java虚拟机 或 Android虚拟机。通常来说开发者写的代码经过“前端编译器”编译成字节码文件集（Java-jar, Android-dex等）之后交给虚拟机，而虚拟机加载这些字节码文件集就">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yummylau.com/2019/03/01/java_2019-03-01_类加载器/">





  <title>聊一聊 "类加载器" | YummyLau</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YummyLau</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep moving！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yummylau.com/2019/03/01/java_2019-03-01_类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yummyLau">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YummyLau">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">聊一聊 "类加载器"</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-01T00:00:00+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/01/java_2019-03-01_类加载器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/java_2019-03-01_类加载器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>阅读本文你能收获到</strong></p>
<ul>
<li>了解 Java/Android中类加载器及其工作流程</li>
<li>Android 开发过程中类加载器的应用场景</li>
</ul>
<p></p><h3 id="1">类加载器</h3><br>类加载器是虚拟机运行时动态加载字节码文件的入口。注意这里的虚拟机并不特指 Java虚拟机 或 Android虚拟机。通常来说开发者写的代码经过“前端编译器”编译成字节码文件集（Java-jar, Android-dex等）之后交给虚拟机，而虚拟机加载这些字节码文件集就是通过类加载器完成。<p></p>
<p>应用程序包的字节码文件集是经过“前段编译器”精挑细选得到的，程序运行所需要的任意代码及资源都被打进程序包中。但实际上用户在使用程序时往往难以走遍程序所有逻辑，因此虚拟机只需按需加载当前用户场景所涉及到的代码。这便决定了类加载器的加载场景 “按需加载”。</p>
<p>应用程序包实际运行是依赖“运行环境”的。比如 Java 程序需要依赖 JRE 进行运行，而 Android 程序则依赖 Application Framework。当然这里讨论的仅仅是下面第一层，更下层的还有Kernel等不在讨论范围内。而这些环境运行时提供了运行程序库依赖的支持。如果应用程序包中使用了运行环境中的类，那运行时这部分类该如何加载？ 同时，应用程序内的类又是如何加载的呢？ 事实上，虚拟机对要加载的类进行“域”划分，不同“域”的加载委托给不同的类加载器进行加载，这种加载模式称为 “委托加载”。</p>
<h4 id="1_3">委托加载 </h4>

<p>除了系统提供的类加载，开发者也可以自定义 ClassLoader，在整个应用程序加载流程中所有类加载器有严格的加载逻辑, 按照 ”按需加载，委托加载“ 的思想组合起来一起完成类加载，这种模型称为 ”双亲委派模型“。在了解 Java 和 Android 平台的类加载器之前，我们先看下委托加载的流程。整个 “委托加载” 的思想都体现在 <a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/ojluni/src/main/java/java/lang/ClassLoader.java" target="_blank" rel="noopener">Java.lang.ClassLoader</a>, 两个平台的加载流程方向上是一致的。</p>
<p><code>ClassLoader</code> 是一个抽象类, 没有抽象方法, 加载流程统一集中在 <a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/ojluni/src/main/java/java/lang/ClassLoader.java#359" target="_blank" rel="noopener">ClassLoader#loadClass</a>.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">Class</span>&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                	<span class="comment">// 2</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 3</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>1处</code> 通过 native （VMClassLoader实现）手段检测当前 ClassLoader 是否已经加载过该类， 如果加载过则直接返回。</li>
<li><code>2处</code> 当且仅当 ClassLoader 没有加载过类且父加载器存在时, 尝试调用 <em>parent#loadClass</em> 获取</li>
<li><code>3处</code> 当且仅当 ClassLoader 没有加载过类且父加载器不存在时, 尝试通过 native 手段从引导类加载器获取</li>
<li>如果上述途径都没有获取到, 则 findClass 获取, 默认方法内抛出异常, 子类需要实现覆盖实现自己的逻辑。</li>
</ul>
<p>活动图如下 </p>
<p><img src="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_1.png" width="300" height="350" alt="图片名称" align="center"></p>
<p>值得注意的是, <em>loadClass</em> 一个 <strong>protected</strong> 权限级别的方法, 这意味着 ”双亲委派模型“ 并不是唯一的加载模式而是系统建议我们使用的模式。</p>
<p>再来看看 Java 和 Android 平台提供哪些类加载器, 以 Android 加载器的内容重点展开。</p>
<h4 id="1_1">Java 流派</h4>

<p>Java系统主要提供了 3 种类加载器</p>
<ol>
<li><code>Bootstrap Classloader</code>，启动类加载器，负责加载 \lib 目录下或者被 -Xbootclasspath参数所指定的路径种的，能被虚拟机识别的类库 （即所有 java.* 开头的类）。</li>
<li><code>Extension Classloader</code>，扩展类加载器，负责加载 \lib\ext 目录下或者被 java.ext.dirs 系统变量指定路径的类库（例如所有 javax.* 开头的类和存放在 JRE 的 ext 目录下的类）。</li>
<li><code>Application Classloader</code>，应用程序类加载器，负责加载用户类路径指定的类库，开发者可以直接使用这个类加载器（即我们自己写的 Java程序时新创建的类都是通过它来接在的）。</li>
</ol>
<h4 id="1_2">Android 流派</h4>

<p>Android系统也提供了多种类加载器, 这些类加载器都由 <code>java.lang.ClassLoader</code> 继承而来。</p>
<blockquote>
<p>ps: 本文所涉及到的源码均以 Andriod P 版本作为展开分析</p>
</blockquote>
<p>以 Android 类加载为例子，这里画了类图方便直观预览。</p>
<p><img src="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_2.png" width="1000" height="600" alt="图片名称" align="center"></p>
<p>上述类图除了橙色的 <code>DexPathList</code> 类之外, 其他都是 Android 提供的类加载器。按照 Java 系统类加载器的划分, Android 类加载器大致也可以划分 3 种类加载器。</p>
<ol>
<li>加载 Framework 层类,  <code>BootClassLoader</code> 为该类型类加载器, 在 Android 系统启动的时候创建该实例, 当应用程序系统也需要用到 Framework 类是会传递该类加载器实例给应用层。</li>
<li>加载已经安装的 apk 中的类, <code>PathClassLoader</code> 为该类型类加载器。</li>
<li>加载jar/apk/dex,未安装过的 apk 中的类, <code>DexClassLoader</code> 或 <code>PathClassLoader</code> 为该类型类加载器。</li>
</ol>
<blockquote>
<p>这里可能和你平时在网上看到的结论是不一样的, PathClassLoader 也可以加载外部 dex 了？ 肯定的啊。 看下面分析。</p>
</blockquote>
<p></p><h3 id="3"> BaseDexClassLoader </h3><br>Android 应用层的类加载逻辑基本围绕 <code>BaseDexClassLoader</code> 及子类开展的, 也是应用层开发热修复, 插件化技术中重要的技术基础。下面重点分析这部分内容, 在掌握这部分知识之前, 希望我们能达成一致的共识 “带着问题在源码中找答案”。<p></p>
<p>待解决的问题 ：</p>
<ul>
<li>BaseDexClassLoader的设计初衷是什么? </li>
<li>如何加载 Dex 文件 ？</li>
<li>子类的应用场景是什么 ?</li>
<li>实际开发过程我们可以如何使用 ？ </li>
</ul>
<h4 id="3_1">设计初衷</h4>

<p>由于移动端架构及性能原因, Android 针对 class 文件进一步优化形成 dex 文件。 为了适配加载 dex 文件, <code>BaseDexClassLoader</code> 应运而生。 在<a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java#51" target="_blank" rel="noopener">BaseDexClassLoader.DexPathList</a> 源码中可知, <code>BaseDexClassLoader</code> 加载 dex 实际上是委托 <code>DexPathList</code> 对象进行的。</p>
<h4 id="3_2">如何加载 Dex 文件</h4>

<p>在 <code>BaseDexClassLoader</code> 中有一个重要的成员变量 <code>pathList</code>, 是一个 <code>DexPathList</code> 类型对象。结合 <a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">BaseDexClassLoader.DexPathList</a>源码及类图可以理解, <code>DexPathList</code> 托管处理了 <code>BaseDexClassLoader</code> 查找资源的过程。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from BaseDexClassLoader.java 部分源码做过删减</span></span><br><span class="line"> <span class="keyword">public</span> BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">            String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, optimizedDirectory);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(ByteBuffer[] dexFiles, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexFiles, librarySearchPath);</span><br><span class="line">        <span class="keyword">this</span>.sharedLibraryLoaders = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findLibrary</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sharedLibraryLoaders != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ClassLoader loader : sharedLibraryLoaders) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="function"><span class="keyword">return</span> loader.<span class="title">loadClass</span><span class="params">(name)</span></span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findClass</span><span class="params">(name, suppressedExceptions)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sharedLibraryLoaders != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ClassLoader loader : sharedLibraryLoaders) &#123;</span><br><span class="line">            URL url = loader.getResource(name);</span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> url;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findResource</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Enumeration&lt;URL&gt; findResources(String name) &#123;</span><br><span class="line">    Enumeration&lt;URL&gt; myResources = pathList.findResources(name);</span><br><span class="line">    <span class="keyword">if</span> (sharedLibraryLoaders == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> myResources;</span><br><span class="line">    &#125;</span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp =</span><br><span class="line">        (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> Enumeration&lt;?&gt;[sharedLibraryLoaders.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sharedLibraryLoaders.length; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tmp[i] = sharedLibraryLoaders[i].getResources(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[sharedLibraryLoaders.length] = myResources;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建 <code>BaseDexClassLoader</code> 对象的同时也创建了 <code>DexPathList</code> 对象。 <em>sharedLibraryLoaders</em> 是共享的 <strong>Loader</strong> 数组, 在查找 Resource 和 Class 是优先从 <em>sharedLibraryLoaders</em> 中获取, 这些 <strong>Loader</strong> 也是调用各自的查找方法, 最终会依赖 DexPathList 对象进行查找。</p>
<p>在熟悉 <a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="noopener">DexPathList</a> 之前看下其构造器。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Element[] dexElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles,<span class="keyword">String</span> librarySearchPath) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DexPathList(ClassLoader definingContext, <span class="keyword">String</span> dexPath, <span class="keyword">String</span> librarySearchPath, <span class="built_in">File</span> optimizedDirectory) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>definingContext</em> 为关联的 ClassLoader</li>
<li><em>dexFiles</em> 内存中已经存在的 dex 缓存</li>
<li><em>librarySearchPath</em> native 库的路径</li>
<li><em>optimizedDirectory</em> 存放优化过的 dex 文件</li>
</ul>
<p><em>dexElements</em> 是存放加载过的 dex 或 resource 资源。</p>
<p>下面重点看下 <a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/DexPathList.java#497" target="_blank" rel="noopener">findClass</a> 逻辑</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        <span class="keyword">Class</span>&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.<span class="keyword">asList</span>(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Element &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A file denoting a zip file (in case of a resource jar or a dex jar), or a directory</span></span><br><span class="line"><span class="comment">     * (only when dexFile is null).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">File</span> path;</span><br><span class="line">    <span class="comment">/** Whether &#123;@code path.isDirectory()&#125;, or &#123;@code null&#125; if &#123;@code path == null&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">Boolean</span> pathIsDirectory;</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line">    <span class="keyword">private</span> ClassPathURLStreamHandler urlHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Element</code>是一个静态类, 封装了一个 Dex 单元. 而 <em>findClass</em> 从 <em>dexElements</em> 数组中获取, 所以追踪 <em>dexElements</em> 初始化。</p>
<ul>
<li><a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/DexPathList.java#150" target="_blank" rel="noopener">构造器-从ByteBuffer[]中读取（调用 makeDexElements）</a></li>
<li><a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/DexPathList.java#122" target="_blank" rel="noopener">构造器-从dexPath中读取（调用 makeInMemoryDexElements）</a></li>
<li><a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/DexPathList.java#238" target="_blank" rel="noopener">addDexPath-从新的dexPath中读取 （直接 new Element[]）</a></li>
</ul>
<p><em>makeInMemoryDexElements</em> 方法直接读取 dexFiles（ByteBuffer[]）, 类似于写文件。<em>makeDexElements</em> 则是从特定 path 下读取 dex 。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(List&lt;<span class="keyword">File</span>&gt; files, <span class="keyword">File</span> optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, <span class="keyword">boolean</span> isTrusted) &#123;</span><br><span class="line">  Element[] elements = <span class="keyword">new</span> Element[files.<span class="keyword">size</span>()];</span><br><span class="line">  <span class="keyword">int</span> elementsPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">File</span> <span class="keyword">file</span> : files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">file</span>.isDirectory()) &#123;</span><br><span class="line">          elements[elementsPos++] = <span class="keyword">new</span> Element(<span class="keyword">file</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">file</span>.isFile()) &#123;</span><br><span class="line">          String name = <span class="keyword">file</span>.getName();</span><br><span class="line">          DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 以 .dex 结尾</span></span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  dex = loadDexFile(<span class="keyword">file</span>, optimizedDirectory, loader, elements);</span><br><span class="line">                  <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      elements[elementsPos++] = <span class="keyword">new</span> Element(dex, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  dex = loadDexFile(<span class="keyword">file</span>, optimizedDirectory, loader, elements);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (dex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> Element(<span class="keyword">file</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> Element(dex, <span class="keyword">file</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (dex != <span class="keyword">null</span> &amp;&amp; isTrusted) &#123;</span><br><span class="line">            dex.setTrusted();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + <span class="keyword">file</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (elementsPos != elements.length) &#123;</span><br><span class="line">      elements = Arrays.copyOf(elements, elementsPos);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DexFile loadDexFile(<span class="keyword">File</span> <span class="keyword">file</span>, <span class="keyword">File</span> optimizedDirectory, ClassLoader loader,</span><br><span class="line">                                   Element[] elements)</span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(<span class="keyword">file</span>, loader, elements);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(<span class="keyword">file</span>, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(<span class="keyword">file</span>.getPath(), optimizedPath, <span class="number">0</span>, loader, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String optimizedPathFor(<span class="keyword">File</span> path,</span><br><span class="line">        <span class="keyword">File</span> optimizedDirectory) &#123;</span><br><span class="line">    String fileName = path.getName();</span><br><span class="line">    <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fileName += DEX_SUFFIX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</span><br><span class="line">            sb.<span class="keyword">append</span>(fileName, <span class="number">0</span>, lastDot);</span><br><span class="line">            sb.<span class="keyword">append</span>(DEX_SUFFIX);</span><br><span class="line">            fileName = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">File</span> result = <span class="keyword">new</span> <span class="keyword">File</span>(optimizedDirectory, fileName);</span><br><span class="line">    <span class="keyword">return</span> result.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 dexPath 中读取文件数组之后, 无论是否以 .dex 后缀结尾的文件, 都通过 <em>loadDexFile</em> 方法进行读取。唯一不同的地方在于, 当 <em>optimizedDirectory</em> 不为 null 时则通过 <em>DexFile.loadDex</em> 加载, 否则直接 new 一个 <code>DexFile</code> 对象。</p>
<p><em>optimizedPathFor</em> 是用于转换文件后缀名的。 如果文件没有带.标识符则默认拼接 <code>.dex</code> 后缀, 否则则改写后缀为 <code>.dex</code>。 这样做得意义在于虚拟机能通过后缀名识别包含 dex 的文件提高读取效率。 </p>
<p><a href="https://android.googlesource.com/platform/libcore/+/refs/heads/master/dalvik/src/main/java/dalvik/system/DexFile.java" target="_blank" rel="noopener">DexFile.java</a> 是如何加载 dex 的呢？ </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DexFile(<span class="keyword">String</span> sourceName, <span class="keyword">String</span> outputName, <span class="built_in">int</span> flags, ClassLoader loader,</span><br><span class="line">        DexPathList.Element[] elements) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> parent = <span class="keyword">new</span> File(outputName).getParent();</span><br><span class="line">            <span class="keyword">if</span> (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Optimized data directory "</span> + parent</span><br><span class="line">                        + <span class="string">" is not owned by the current user. Shared storage cannot protect"</span></span><br><span class="line">                        + <span class="string">" your application from code injection attacks."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">            <span class="comment">// assume we'll fail with a more contextual error later</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCookie = openDexFile(sourceName, outputName, flags, loader, elements);</span><br><span class="line">    mInternalCookie = mCookie;</span><br><span class="line">    mFileName = sourceName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span> openDexFile(<span class="keyword">String</span> sourceName, <span class="keyword">String</span> outputName, <span class="built_in">int</span> flags,</span><br><span class="line">        ClassLoader loader, DexPathList.Element[] elements) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Use absolute paths to enable the use of relative paths when testing on host.</span></span><br><span class="line">    <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> File(sourceName).getAbsolutePath(),</span><br><span class="line">                             (outputName == <span class="keyword">null</span>)</span><br><span class="line">                                 ? <span class="keyword">null</span></span><br><span class="line">                                 : <span class="keyword">new</span> File(outputName).getAbsolutePath(),</span><br><span class="line">                             flags,</span><br><span class="line">                             loader,</span><br><span class="line">                             elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">Object</span> openDexFileNative(<span class="keyword">String</span> sourceName, <span class="keyword">String</span> outputName, <span class="built_in">int</span> flags,</span><br><span class="line">        ClassLoader loader, DexPathList.Element[] elements);</span><br></pre></td></tr></table></figure>
<p><code>DexPathList#loadDexFile</code> 最终都是调用的是 DexFile 构造器。<em>optimizedDirectory</em> 不为 null 的场景下：<em>outputName</em> 为 null 且 flags 为 0。 <em>openDexFileNative</em> 是一个 native 方法。 </p>
<blockquote>
<p>nativa 方法如何追踪呢， 下载 aosp源代码之后, 使用 vs 进行预览。 DexFile 的包名为 “dalvik.system”, 则 native 文件名为 “dalvik_sytem_DexFile” 搜索一下就定位到了。 其中 DexFile_openDexFileNative 方法就是对应的 native 方法。</p>
</blockquote>
<p>native 代码在虚拟机内部。<a href="https://android.googlesource.com/platform/art/+/refs/heads/master/runtime/native/dalvik_system_DexFile.cc" target="_blank" rel="noopener">dalvik_system_DexFile.cc</a> 为官方源码。有兴趣可以 dowm 下来看看。</p>
<p>下面为整个 dex 加载流程的时序图. </p>
<p><img src="https://raw.githubusercontent.com/YummyLau/hexo/master/source/pics/java/classloader_3.png" width="550" height="330" alt="图片名称" align="center"></p>
<h4 id="3_3">子类应用场景</h4>

<p>BaseDexClassLoader的众多子类并没有覆盖其任何方法, 唯一不同的地方在于每个子类的构造器调用 super 参数不一致。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from PathClassLoader.java</span></span><br><span class="line"> <span class="selector-tag">public</span> <span class="selector-tag">PathClassLoader</span>(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">       <span class="selector-tag">super</span>(dexPath, null, null, parent);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-tag">public</span> <span class="selector-tag">PathClassLoader</span>(String dexPath, String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">       <span class="selector-tag">super</span>(dexPath, null, librarySearchPath, parent);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//from DexClassLoader.java</span></span><br><span class="line"> <span class="selector-tag">public</span> <span class="selector-tag">DexClassLoader</span>(String dexPath, String optimizedDirectory,</span><br><span class="line">           String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">       <span class="selector-tag">super</span>(dexPath, null, librarySearchPath, parent);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//from InMemoryDexClassLoader</span></span><br><span class="line"> <span class="selector-tag">public</span> <span class="selector-tag">InMemoryDexClassLoader</span>(<span class="variable">@NonNull</span> ByteBuffer <span class="variable">@NonNull</span> [] dexBuffers,</span><br><span class="line">           <span class="variable">@Nullable</span> String librarySearchPath, <span class="variable">@Nullable</span> ClassLoader parent) &#123;</span><br><span class="line">       <span class="selector-tag">super</span>(dexBuffers, librarySearchPath, parent);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-tag">public</span> <span class="selector-tag">InMemoryDexClassLoader</span>(<span class="variable">@NonNull</span> ByteBuffer <span class="variable">@NonNull</span> [] dexBuffers,</span><br><span class="line">           <span class="variable">@Nullable</span> ClassLoader parent) &#123;</span><br><span class="line">       <span class="selector-tag">this</span>(dexBuffers, null, parent);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-tag">public</span> <span class="selector-tag">InMemoryDexClassLoader</span>(<span class="variable">@NonNull</span> ByteBuffer dexBuffer, <span class="variable">@Nullable</span> ClassLoader parent) &#123;</span><br><span class="line">       <span class="selector-tag">this</span>(new ByteBuffer[] &#123; <span class="selector-tag">dexBuffer</span> &#125;, <span class="selector-tag">parent</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以确定的是 InMemoryDexClassLoader 不从 dexPath 路径中加载 dex 文件而是从 dex 缓存内容中读取。 但是 <code>DexClassLoader</code> 和 <code>PathClassLoader</code> 存在一样的构造器啊。翻开 BaseDexClassLoader 文档一开</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizedDirectory	File: <span class="keyword">this</span> parameter <span class="keyword">is</span> deprecated <span class="keyword">and</span> has <span class="literal">no</span> effect since API level <span class="number">26.</span></span><br></pre></td></tr></table></figure>
<p>optimizedDirectory 在 8.0 版本废弃会有什么影响呢 ？ <em>optimizedDirectory</em> 是存放被优化过的 dex。在 dex 文件首次被加载的时候, 虚拟机会执行 <code>dexopt</code> 操作, 而 <em> optimizedDirectory</em> 就是优化后的odex文件的存放目录。在 <code>native</code> 加载 dex过程中, 如果 <em>outputName</em> 参数为 null 时则默认把优化后的的dex保存在为 <a href="mailto:`/data/dalvik-cache/xxx@classes.dex" target="_blank" rel="noopener">`/data/dalvik-cache/xxx@classes.dex</a><code>。 而</code>PathClassLoader<code>默认 *outputName* 参数为 null, 则 app 启动加载dex生成的优化文件正是存放在</code><a href="mailto:/data/dalvik-cache/xxx@classes.dex" target="_blank" rel="noopener">/data/dalvik-cache/xxx@classes.dex</a><code>。8.0 之前 DexClassLoader 可以指定生成 odex 文件存放的目录，而 8.0 之后则不可以了, 默认都存在</code><a href="mailto:/data/dalvik-cache/xxx@classes.dex" target="_blank" rel="noopener">/data/dalvik-cache/xxx@classes.dex</a>`。 从官网最新的文档上可以看到</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span><span class="keyword">from</span> PathClassLoader.java</span><br><span class="line">* Provides a simple &#123;@link ClassLoader&#125; implementation that operates <span class="literal">on</span> a list</span><br><span class="line">* <span class="keyword">of</span> files <span class="keyword">and</span> directories <span class="keyword">in</span> the local file system, but does <span class="keyword">not</span> attempt to</span><br><span class="line">* load classes <span class="keyword">from</span> the network. Android uses <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">for</span> <span class="title">its</span> <span class="title">system</span> <span class="title">class</span></span></span><br><span class="line">* loader <span class="keyword">and</span> <span class="keyword">for</span> its application <span class="class"><span class="keyword">class</span> <span class="title">loader</span>(<span class="title">s</span>).</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span><span class="keyword">from</span> DexClassLoader.java </span><br><span class="line">* A <span class="class"><span class="keyword">class</span> <span class="title">loader</span> <span class="title">that</span> <span class="title">loads</span> <span class="title">classes</span> <span class="title">from</span> &#123;@<span class="title">code</span> .<span class="title">jar</span>&#125; <span class="title">and</span> &#123;@<span class="title">code</span> .<span class="title">apk</span>&#125; <span class="title">files</span></span></span><br><span class="line">* containing a &#123;@code classes.dex&#125; entry. This can be used to execute code <span class="keyword">not</span></span><br><span class="line">* installed <span class="keyword">as</span> part <span class="keyword">of</span> an application</span><br><span class="line">* Prior to API level <span class="number">26</span>, <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">loader</span> <span class="title">requires</span> <span class="title">an</span></span></span><br><span class="line">* application-private, writable directory to cache optimized classes.</span><br><span class="line">* Use &#123;@code Context.getCodeCacheDir()&#125; to create such a directory:</span><br><span class="line">* &lt;pre&gt;   &#123;@code</span><br><span class="line">*   File dexOutputDir = context.getCodeCacheDir();</span><br><span class="line">* &#125;&lt;/pre&gt;</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt;&lt;strong&gt;Do <span class="keyword">not</span> cache optimized classes <span class="literal">on</span> external storage.&lt;/strong&gt;</span><br><span class="line">* External storage does <span class="keyword">not</span> provide access controls necessary to protect your</span><br><span class="line">* application <span class="keyword">from</span> code injection attacks</span><br></pre></td></tr></table></figure>
<p>就是为了保证新版本<code>DexClassLoader</code> 加载生成的 odex 文件不被随便存放, 其目的是为了避免加载的内容会对应用造成攻击。</p>
<p>这里放一下 app 默认的 PathClassLoader 加载流程：</p>
<ol>
<li>ActivityThread#handleBindApplication</li>
<li>ContextImpl#getClassLoader</li>
<li>LoadedApk#makePaths(计算dexPath) -&gt; LoadedApk#getClassLoader </li>
<li>ApplicationLoaders#getClassLoader</li>
<li>PathClassLoaderFactory#createClassLoader</li>
<li>PathClassLoader#构造器</li>
</ol>
<p>有兴趣的朋友可以翻阅源码查看。</p>
<p>在 api 27 （Android 8.1） 中新增 <code>DelegateLastClassLoader</code>， 该类继承 <code>PathClassLoader</code> 。在 <a href="#1_3">委托加载</a> 章节中最后提到, “双亲委派模型”的加载并不是唯一的方式, 而 <code>DelegateLastClassLoader</code> 就是最好的证明。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from DelagateLastClassLoader.java</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">     		</span><br><span class="line">        <span class="comment">// 1		</span></span><br><span class="line">        Class&lt;?&gt; cl = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Object.<span class="keyword">class</span>.getClassLoader().loadClass(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        ClassNotFoundException fromSuper = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findClass(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            fromSuper = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getParent().loadClass(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> fromSuper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>1处</code> 通过 native （VMClassLoader实现）手段检测当前 ClassLoader 是否已经加载过该类， 如果加载过则直接返回。</li>
<li><code>2处</code> 尝试通过 native 手段从引导类加载器获取</li>
<li><code>3处</code> 则 findClass 获取, 默认方法内抛出异常, 子类需要实现覆盖实现自己的逻辑</li>
<li><code>4处</code> 则尝试调用 <em>parent#loadClass</em> 获取</li>
</ul>
<h4 id="3_4">实际开发的应用</h4>

<p><strong>插桩实现</strong></p>
<p>广为人知的 Qzone 补丁方案就是通过插桩实现热修复, 下面为伪代码（8.0版本之前）, 略去反射实现</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">String</span> dexPath = <span class="string">"补丁路径"</span>;</span><br><span class="line"><span class="keyword">String</span> dexoptPath = <span class="string">"xxxx/dexopt/"</span>;</span><br><span class="line">DexClassLoader dexClassLoader = <span class="keyword">new</span> <span class="type">DexClassLoader</span>(dexPath, dexoptPath, dexoptPath, getClassLoader());</span><br><span class="line">DexPathList <span class="keyword">new</span><span class="type">PathList</span> = dexClassLoader.pathList ;</span><br><span class="line">Element[] <span class="keyword">new</span><span class="type">Elements</span> = <span class="keyword">new</span><span class="type">PathList</span>.elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">DexPathList currentPathList = getBaseDexClassLoader().pathList;</span><br><span class="line">Element[] currentElements = pathList.elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">Element[] resultElements = mergeElement(<span class="keyword">new</span><span class="type">Elements</span>, currentElements);</span><br><span class="line">pathList.elements = resultElements;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>1处</code> 加载补丁 dex </li>
<li><code>2处</code> 反射获取当前 dex 数组</li>
<li><code>3处</code> 把补丁 dex 查到 当前 dex 数组前面</li>
</ul>
<p>这样一来, 在 <code>DexPathList#findClass</code> 过程中, 新插入的 element 元素就会优先被遍历到使用。 </p>
<p>但是, 如果 currentElements 中某个 dex 中的类 A 持有 newElements 中某个 dex 中的类 B 的引用， 运行时会出现 <code>Class ref in pre-verified clas resolved to unexpected implementation</code> 。了解原因前得清楚虚拟机在 native 加载类的时候大致会做哪些工作。</p>
<ol>
<li><p>dexopt 会进行类校验 。比如校验 A 中 “static 方法，private 方法，构造函数，虚函数第一层引用 （c++）” 是否存在对某些类的引用且他们和 A 是在同个dex。 如果是则 A 会打上  “CLASS_ISPREVERIFIED” 。</p>
</li>
<li><p>虚拟机加载类的顺序为: <strong>dvmResolveClass</strong>  -&gt; <strong>dvmLinkClass</strong> -&gt; <strong>dvmInitClasss</strong> 。 在 <strong>dvmResolveClass</strong> 会校验如果类被打上 CLASS_ISPREVERIFIED，则需要检验其引用类是否是同一个 dex ，不在同个 dex 则抛出 Exception。</p>
</li>
</ol>
<p>既然如此, 那么就在 A 的 “static 方法，private 方法，构造函数，虚函数第一层引用 （c++）” 中任意一处引用另外一个 dex 的某个类来防止 A 被打上 “CLASS_ISPREVERIFIED”。 可以借助 gradle 入侵 dex 打包流程, 利用字节码技术对所有类的构造器插入对该 dex 中某个类的引用进而解决问题。 </p>
<p><strong>tinker Android N 类加载</strong></p>
<p><a href="https://github.com/WeMobileDev/article/blob/master/Android_N%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%B9%E7%83%AD%E8%A1%A5%E4%B8%81%E5%BD%B1%E5%93%8D%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Android_N混合编译与对热补丁影响解析</a> 中一文已经明确指出 “无论是使用插入pathlist还是parent classloader的方式，若补丁修改的class已经存在与app image，它们都是无法通过热补丁更新的。它们在启动app时已经加入到PathClassLoader的ClassTable中，系统在查找类时会直接使用base.apk中的class。” </p>
<p>为了解决这种问题， tinker 团队选择在 Android N 及以上版本采用 “运行时替换PathClassLoader方案” 以达到废除 cache 效果。</p>
<p><a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java" target="_blank" rel="noopener">SystemClassLoaderAdder#installDexes</a> 中针对版本构建不同的 ClassLoader 对象。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> installDexes(Application application, PathClassLoader loader, <span class="keyword">File</span> dexOptDir, List&lt;<span class="keyword">File</span>&gt; files)</span><br><span class="line">    <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        files = createSortedAdditionalPathEntries(files);</span><br><span class="line">        ClassLoader classLoader = loader;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span> &amp;&amp; !checkIsProtectedApp(files)) &#123;</span><br><span class="line">            classLoader = AndroidNClassLoader.<span class="keyword">inject</span>(loader, application);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AndroidNClassLoader <span class="keyword">inject</span>(PathClassLoader originClassLoader, Application application) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader, application);</span><br><span class="line">    reflectPackageInfoClassloader(application, classLoader);</span><br><span class="line">    <span class="keyword">return</span> classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Android N 上选择 <a href="https://github.com/Tencent/tinker/blob/master/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java" target="_blank" rel="noopener">AndroidNClassLoader</a> 。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AndroidNClassLoader createAndroidNClassLoader(PathClassLoader originalClassLoader, Application application) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> AndroidNClassLoader androidNClassLoader = <span class="keyword">new</span> AndroidNClassLoader(<span class="string">""</span>,  originalClassLoader, application);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">final</span> Field pathListField = ShareReflectUtil.findField(originalClassLoader, <span class="string">"pathList"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> originPathList = pathListField.<span class="built_in">get</span>(originalClassLoader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">Object</span> newPathList = recreateDexPathList(originPathList, androidNClassLoader, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    pathListField.<span class="built_in">set</span>(androidNClassLoader, newPathList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    ShareReflectUtil.findField(originPathList, <span class="string">"definingContext"</span>).<span class="built_in">set</span>(originPathList, androidNClassLoader);</span><br><span class="line"></span><br><span class="line">    oldDexPathListHolder = originPathList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> androidNClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>1处</code> 创建 <em>androidNClassLoader</em> 对象 </li>
<li><code>2处</code> 反射获取原来的 <em>originPathList</em> 对象</li>
<li><code>3处</code> 通过反射取出 <em>originPathList</em> 对象的各个属性信息并反射构建一个新的 <code>DexPathList</code> 对象</li>
<li><code>4处</code> <code>DexPathList</code> 对象关联 <em>androidNClassLoader</em> </li>
<li><code>5处</code> <em>androidNClassLoader</em> 持有 <code>DexPathList</code> 对象</li>
</ul>
<p>而在 <em>findClass</em> 过程中针对 application, tinker 库内的 loader 及一些特殊库文件, 默认使用 PathClassLoader 加载, 其他的优先使用 <em>androidNClassLoader</em> 查找。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationClassName != <span class="keyword">null</span> &amp;&amp; applicationClassName.equals(name)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> originClassLoader.<span class="title">loadClass</span><span class="params">(name)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.startsWith(<span class="string">"com.tencent.tinker.loader."</span>)</span><br><span class="line">            &amp;&amp; !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> originClassLoader.<span class="title">loadClass</span><span class="params">(name)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.startsWith(<span class="string">"org.apache.http."</span>)) &#123;</span><br><span class="line">        <span class="comment">// Here's the whole story:</span></span><br><span class="line">        <span class="comment">//   Some app use apache wrapper library to access Apache utilities. Classes in apache wrapper</span></span><br><span class="line">        <span class="comment">//   library may be conflict with those preloaded in BootClassLoader.</span></span><br><span class="line">        <span class="comment">//   So with the build option:</span></span><br><span class="line">        <span class="comment">//       useLibrary 'org.apache.http.legacy'</span></span><br><span class="line">        <span class="comment">//   appears, the Android Framework will inject a jar called 'org.apache.http.legacy.boot.jar'</span></span><br><span class="line">        <span class="comment">//   in front of the path of user's apk. After that, PathList in app's PathClassLoader should</span></span><br><span class="line">        <span class="comment">//   look like this:</span></span><br><span class="line">        <span class="comment">//       ["/system/framework/org.apache.http.legacy.boot.jar", "path-to-user-apk", "path-to-other-preload-jar"]</span></span><br><span class="line">        <span class="comment">//   When app runs to the code refer to Apache classes, the referred classes in the first</span></span><br><span class="line">        <span class="comment">//   jar override those in user's app, which avoids any conflicts and crashes.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   When it comes to Tinker, to block the cached instances in class table of app's</span></span><br><span class="line">        <span class="comment">//   PathClassLoader we use this AndroidNClassLoader to replace the original PathClassLoader.</span></span><br><span class="line">        <span class="comment">//   At the beginning it's fine to imitate system's behavior and construct the PathList in AndroidNClassLoader</span></span><br><span class="line">        <span class="comment">//   like below:</span></span><br><span class="line">        <span class="comment">//       ["/system/framework/org.apache.http.legacy.boot.jar", "path-to-new-dexes", "path-to-other-preload-jar"]</span></span><br><span class="line">        <span class="comment">//   However, the ART VM of Android P adds a new feature that checks whether the inlined class is loaded by the same</span></span><br><span class="line">        <span class="comment">//   ClassLoader that loads the callsite's class. If any Apache classes is inlined in old dex(oat), after we replacing</span></span><br><span class="line">        <span class="comment">//   the App's ClassLoader we will receive an assert since the Apache classes is loaded by another ClassLoader now.</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> originClassLoader.<span class="title">loadClass</span><span class="params">(name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">findClass</span><span class="params">(name)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// Some jars/apks other than base.apk was removed from AndroidNClassloader's dex path list.</span></span><br><span class="line">        <span class="comment">// So if target class cannot be found in AndroidNClassloader, we should fallback to try</span></span><br><span class="line">        <span class="comment">// original PathClassLoader for compatibility.</span></span><br><span class="line">        <span class="comment">// Obviously this behavior violates the Parent Delegate Model, but it doesn't matter.</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> originClassLoader.<span class="title">loadClass</span><span class="params">(name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于自己能力有限，如果本文中有遗漏或者错误的地方，请在评论区指出或者通过 <a href="mailto:yummyl.lau@gmail.com" target="_blank" rel="noopener">yummyl.lau@gmail.com</a> 邮件联系我，感谢。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    yummyLau
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yummylau.com/2019/03/01/java_2019-03-01_类加载器/" title="聊一聊 " 类加载器"">http://yummylau.com/2019/03/01/java_2019-03-01_类加载器/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/类加载/" rel="tag"># 类加载</a>
          
            <a href="/tags/ClassLoader/" rel="tag"># ClassLoader</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/28/java_2019-03-01_class文件解析/" rel="next" title="如何读懂一个 class 文件">
                <i class="fa fa-chevron-left"></i> 如何读懂一个 class 文件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/08/java_2019-03-08_类加载流程/" rel="prev" title="窥探 Java 类加载">
                窥探 Java 类加载 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="yummyLau">
            
              <p class="site-author-name" itemprop="name">yummyLau</p>
              <p class="site-description motion-element" itemprop="description">努力让自己更优秀。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/YummyLau" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1"><span class="nav-number">1.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1_3"><span class="nav-number">1.1.</span> <span class="nav-text">委托加载 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1_1"><span class="nav-number">1.2.</span> <span class="nav-text">Java 流派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1_2"><span class="nav-number">1.3.</span> <span class="nav-text">Android 流派</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3"><span class="nav-number">2.</span> <span class="nav-text"> BaseDexClassLoader </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3_1"><span class="nav-number">2.1.</span> <span class="nav-text">设计初衷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3_2"><span class="nav-number">2.2.</span> <span class="nav-text">如何加载 Dex 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3_3"><span class="nav-number">2.3.</span> <span class="nav-text">子类应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3_4"><span class="nav-number">2.4.</span> <span class="nav-text">实际开发的应用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yummyLau</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'pPdkM9YTrgYDV8coDCdALdmi-gzGzonHsz',
        appKey: '5HrONz3gb8XPDrUna01sa0gY',
        placeholder: '留下你的足迹呗 ヾﾉ≧∀≦)o',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
